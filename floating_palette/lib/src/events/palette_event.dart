import 'package:flutter/foundation.dart';

/// Base class for palette events.
///
/// Events are sent between host app and palette windows using explicit IDs.
/// IDs are auto-generated by the palette registry as:
/// `${eventNamespace}.${snake_case(className)}` (defaults to palette ID).
///
/// **Defining an event:**
/// ```dart
/// class ItemSelectedEvent extends PaletteEvent {
///   static const id = 'menu.item_selected';
///
///   @override
///   String get eventId => id;
///
///   final String itemId;
///   final int index;
///
///   const ItemSelectedEvent({required this.itemId, required this.index});
///
///   @override
///   Map<String, dynamic> toMap() => {'itemId': itemId, 'index': index};
///
///   static ItemSelectedEvent fromMap(Map<String, dynamic> m) =>
///       ItemSelectedEvent(itemId: m['itemId'], index: m['index']);
/// }
/// ```
///
/// **Type-safe listening:**
/// ```dart
/// controller.onEvent<ItemSelectedEvent>((event) {
///   print('Selected: ${event.itemId}');
/// });
/// ```
@immutable
abstract class PaletteEvent {
  const PaletteEvent();

  /// The stable event ID for serialization.
  ///
  /// This should match the auto-generated ID for the palette and event class.
  ///
  /// Format: `${eventNamespace}.${snake_case(className)}`
  /// Example: `'menu.item_selected'`, `'editor.text_changed'`
  String get eventId;

  /// Serialize event data for cross-engine transfer.
  ///
  /// Override in subclasses that carry data. The default returns empty map.
  Map<String, dynamic> toMap() => {};

  // ═══════════════════════════════════════════════════════════════════════════
  // Registry
  // ═══════════════════════════════════════════════════════════════════════════

  static final _factories = <String, PaletteEvent Function(Map<String, dynamic>)>{};
  static final _typeToId = <Type, String>{};
  static final _idToType = <String, Type>{};

  /// Register an event type for deserialization.
  ///
  /// This is called automatically by generated code during `Palettes.init()`
  /// and `paletteMain()`. You generally don't need to call it manually.
  ///
  /// Throws [StateError] if:
  /// - The same event ID is registered twice with different types
  /// - The same type is registered twice with different IDs
  ///
  /// Note: Re-registering the same type with the same ID is allowed (idempotent)
  /// to support hot restart where both host and palette may register events.
  ///
  /// ```dart
  /// PaletteEvent.register<ItemSelectedEvent>(
  ///   'menu.item_selected',
  ///   ItemSelectedEvent.fromMap,
  /// );
  /// ```
  static void register<T extends PaletteEvent>(
    String eventId,
    T Function(Map<String, dynamic>) fromMap,
  ) {
    // Check for conflicting registrations
    final existingTypeForId = _idToType[eventId];
    final existingIdForType = _typeToId[T];

    if (existingTypeForId != null && existingTypeForId != T) {
      throw StateError(
        "Event ID '$eventId' is already registered for type $existingTypeForId. "
        'Cannot register it for $T. Each event ID must map to exactly one type.',
      );
    }

    if (existingIdForType != null && existingIdForType != eventId) {
      throw StateError(
        "Type $T is already registered with ID '$existingIdForType'. "
        "Cannot register it with ID '$eventId'. Each type must have exactly one ID.",
      );
    }

    // Allow idempotent re-registration (same type, same ID)
    _factories[eventId] = fromMap;
    _typeToId[T] = eventId;
    _idToType[eventId] = T;
  }

  /// Check if an event ID has a registered factory.
  static bool isRegistered(String eventId) => _factories.containsKey(eventId);

  /// Get the event ID for a registered type.
  ///
  /// Returns null if the type hasn't been registered.
  static String? idFor<T extends PaletteEvent>() => _typeToId[T];

  /// Get all registered event IDs.
  static Iterable<String> get registeredIds => _factories.keys;

  /// Deserialize an event from its ID and data.
  ///
  /// Returns null if the event ID is not registered.
  static PaletteEvent? deserialize(String eventId, Map<String, dynamic> data) {
    final factory = _factories[eventId];
    if (factory == null) {
      debugPrint(
        '[PaletteEvent] Unknown event: $eventId. '
        'Did you call PaletteEvent.register()? '
        'Registered: ${_factories.keys.join(', ')}',
      );
      return null;
    }
    return factory(data);
  }

  /// Clear all registered event types.
  ///
  /// Primarily for testing.
  @visibleForTesting
  static void clearRegistry() {
    _factories.clear();
    _typeToId.clear();
    _idToType.clear();
  }
}

/// Exception thrown when deserializing an unknown event type.
class UnknownEventError extends Error {
  final String eventId;
  final List<String> availableIds;

  UnknownEventError(this.eventId, this.availableIds);

  @override
  String toString() =>
      'UnknownEventError: Unknown event "$eventId". '
      'Available: ${availableIds.join(', ')}';
}
