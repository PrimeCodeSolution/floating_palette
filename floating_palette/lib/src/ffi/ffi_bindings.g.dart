// AUTO-GENERATED - DO NOT EDIT
// Generated by ffigen from src/ffi_interface.h
//
// To regenerate: dart run ffigen --config ffigen.yaml
//
// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
import 'dart:ffi' as ffi;

/// Auto-generated FFI bindings for synchronous native calls.
/// Used by SizeReporter, cursor positioning, and screen queries.
///
class FFIBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FFIBindings(ffi.DynamicLibrary dynamicLibrary)
    : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FFIBindings.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// Create a shared path buffer for a palette window.
  /// Returns a pointer that Flutter can write path data to.
  ///
  /// @param window_id  The palette window identifier
  /// @return           Pointer to GlassPathBuffer, or NULL on failure
  ffi.Pointer<ffi.Void> CreateGlassPathBuffer(ffi.Pointer<ffi.Char> window_id) {
    return _CreateGlassPathBuffer(window_id);
  }

  late final _CreateGlassPathBufferPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)
        >
      >('FloatingPalette_CreateGlassPathBuffer');
  late final _CreateGlassPathBuffer =
      _CreateGlassPathBufferPtr.asFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)
      >(isLeaf: true);

  /// Destroy the shared path buffer for a palette window.
  ///
  /// @param window_id  The palette window identifier
  void DestroyGlassPathBuffer(ffi.Pointer<ffi.Char> window_id) {
    return _DestroyGlassPathBuffer(window_id);
  }

  late final _DestroyGlassPathBufferPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
        'FloatingPalette_DestroyGlassPathBuffer',
      );
  late final _DestroyGlassPathBuffer =
      _DestroyGlassPathBufferPtr.asFunction<
        void Function(ffi.Pointer<ffi.Char>)
      >(isLeaf: true);

  /// Get the bounds of the frontmost/active application window.
  /// Useful for positioning palettes relative to the host application.
  ///
  /// @param out_x       Output: Window origin X
  /// @param out_y       Output: Window origin Y
  /// @param out_width   Output: Window width
  /// @param out_height  Output: Window height
  /// @return            true if active window found, false otherwise
  bool GetActiveAppBounds(
    ffi.Pointer<ffi.Double> out_x,
    ffi.Pointer<ffi.Double> out_y,
    ffi.Pointer<ffi.Double> out_width,
    ffi.Pointer<ffi.Double> out_height,
  ) {
    return _GetActiveAppBounds(out_x, out_y, out_width, out_height);
  }

  late final _GetActiveAppBoundsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
          )
        >
      >('FloatingPalette_GetActiveAppBounds');
  late final _GetActiveAppBounds =
      _GetActiveAppBoundsPtr.asFunction<
        bool Function(
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >(isLeaf: true);

  /// Get the bundle identifier or process name of the active application.
  ///
  /// @param out_buffer      Buffer to write the identifier/name
  /// @param buffer_size     Size of the buffer
  /// @return                Length of the identifier, or 0 if not found
  int GetActiveAppIdentifier(
    ffi.Pointer<ffi.Char> out_buffer,
    int buffer_size,
  ) {
    return _GetActiveAppIdentifier(out_buffer, buffer_size);
  }

  late final _GetActiveAppIdentifierPtr =
      _lookup<
        ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>, ffi.Int32)>
      >('FloatingPalette_GetActiveAppIdentifier');
  late final _GetActiveAppIdentifier =
      _GetActiveAppIdentifierPtr.asFunction<
        int Function(ffi.Pointer<ffi.Char>, int)
      >(isLeaf: true);

  /// Get the current cursor (mouse) position in screen coordinates.
  ///
  /// @param out_x  Output: Cursor X position
  /// @param out_y  Output: Cursor Y position
  void GetCursorPosition(
    ffi.Pointer<ffi.Double> out_x,
    ffi.Pointer<ffi.Double> out_y,
  ) {
    return _GetCursorPosition(out_x, out_y);
  }

  late final _GetCursorPositionPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>)
        >
      >('FloatingPalette_GetCursorPosition');
  late final _GetCursorPosition =
      _GetCursorPositionPtr.asFunction<
        void Function(ffi.Pointer<ffi.Double>, ffi.Pointer<ffi.Double>)
      >(isLeaf: true);

  /// Get the screen index where the cursor is currently located.
  ///
  /// @return  Screen index (0-based), or -1 if unable to determine
  int GetCursorScreen() {
    return _GetCursorScreen();
  }

  late final _GetCursorScreenPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
        'FloatingPalette_GetCursorScreen',
      );
  late final _GetCursorScreen = _GetCursorScreenPtr.asFunction<int Function()>(
    isLeaf: true,
  );

  /// Get the full bounds of a screen (including menu bar, dock areas).
  ///
  /// @param screen_index  Screen index (0-based)
  /// @param out_x         Output: Screen origin X
  /// @param out_y         Output: Screen origin Y
  /// @param out_width     Output: Screen width
  /// @param out_height    Output: Screen height
  /// @return              true if screen exists, false otherwise
  bool GetScreenBounds(
    int screen_index,
    ffi.Pointer<ffi.Double> out_x,
    ffi.Pointer<ffi.Double> out_y,
    ffi.Pointer<ffi.Double> out_width,
    ffi.Pointer<ffi.Double> out_height,
  ) {
    return _GetScreenBounds(screen_index, out_x, out_y, out_width, out_height);
  }

  late final _GetScreenBoundsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Int32,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
          )
        >
      >('FloatingPalette_GetScreenBounds');
  late final _GetScreenBounds =
      _GetScreenBoundsPtr.asFunction<
        bool Function(
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >(isLeaf: true);

  /// Get the number of connected screens/monitors.
  ///
  /// @return  Number of screens
  int GetScreenCount() {
    return _GetScreenCount();
  }

  late final _GetScreenCountPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function()>>(
        'FloatingPalette_GetScreenCount',
      );
  late final _GetScreenCount = _GetScreenCountPtr.asFunction<int Function()>(
    isLeaf: true,
  );

  /// Get the scale factor (DPI scaling) of a screen.
  ///
  /// @param screen_index  Screen index (0-based)
  /// @return              Scale factor (1.0 = standard, 2.0 = Retina/HiDPI)
  double GetScreenScaleFactor(int screen_index) {
    return _GetScreenScaleFactor(screen_index);
  }

  late final _GetScreenScaleFactorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int32)>>(
        'FloatingPalette_GetScreenScaleFactor',
      );
  late final _GetScreenScaleFactor =
      _GetScreenScaleFactorPtr.asFunction<double Function(int)>(isLeaf: true);

  /// Get the visible bounds of a screen (excluding menu bar, dock, taskbar).
  /// Use this for constraining palette positions.
  ///
  /// @param screen_index  Screen index (0-based)
  /// @param out_x         Output: Visible area origin X
  /// @param out_y         Output: Visible area origin Y
  /// @param out_width     Output: Visible area width
  /// @param out_height    Output: Visible area height
  /// @return              true if screen exists, false otherwise
  bool GetScreenVisibleBounds(
    int screen_index,
    ffi.Pointer<ffi.Double> out_x,
    ffi.Pointer<ffi.Double> out_y,
    ffi.Pointer<ffi.Double> out_width,
    ffi.Pointer<ffi.Double> out_height,
  ) {
    return _GetScreenVisibleBounds(
      screen_index,
      out_x,
      out_y,
      out_width,
      out_height,
    );
  }

  late final _GetScreenVisibleBoundsPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Int32,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
          )
        >
      >('FloatingPalette_GetScreenVisibleBounds');
  late final _GetScreenVisibleBounds =
      _GetScreenVisibleBoundsPtr.asFunction<
        bool Function(
          int,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >(isLeaf: true);

  /// Get the current frame (position and size) of a palette window.
  ///
  /// @param window_id  The palette window identifier
  /// @param out_x      Output: X position (screen coordinates)
  /// @param out_y      Output: Y position (screen coordinates)
  /// @param out_width  Output: Window width
  /// @param out_height Output: Window height
  /// @return           true if window exists, false otherwise
  bool GetWindowFrame(
    ffi.Pointer<ffi.Char> window_id,
    ffi.Pointer<ffi.Double> out_x,
    ffi.Pointer<ffi.Double> out_y,
    ffi.Pointer<ffi.Double> out_width,
    ffi.Pointer<ffi.Double> out_height,
  ) {
    return _GetWindowFrame(window_id, out_x, out_y, out_width, out_height);
  }

  late final _GetWindowFramePtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
            ffi.Pointer<ffi.Double>,
          )
        >
      >('FloatingPalette_GetWindowFrame');
  late final _GetWindowFrame =
      _GetWindowFramePtr.asFunction<
        bool Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Double>,
        )
      >(isLeaf: true);

  /// Check if a palette window is currently visible.
  ///
  /// @param window_id  The palette window identifier
  /// @return           true if window exists and is visible, false otherwise
  bool IsWindowVisible(ffi.Pointer<ffi.Char> window_id) {
    return _IsWindowVisible(window_id);
  }

  late final _IsWindowVisiblePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Char>)>>(
        'FloatingPalette_IsWindowVisible',
      );
  late final _IsWindowVisible =
      _IsWindowVisiblePtr.asFunction<bool Function(ffi.Pointer<ffi.Char>)>(
        isLeaf: true,
      );

  /// Resize a palette window synchronously.
  /// Called by SizeReporter when content size changes.
  ///
  /// @param window_id  The palette window identifier
  /// @param width      New width in logical pixels
  /// @param height     New height in logical pixels
  void ResizeWindow(
    ffi.Pointer<ffi.Char> window_id,
    double width,
    double height,
  ) {
    return _ResizeWindow(window_id, width, height);
  }

  late final _ResizeWindowPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Double, ffi.Double)
        >
      >('FloatingPalette_ResizeWindow');
  late final _ResizeWindow =
      _ResizeWindowPtr.asFunction<
        void Function(ffi.Pointer<ffi.Char>, double, double)
      >(isLeaf: true);

  /// Enable or disable the glass effect for a palette window.
  /// When enabled, creates NSVisualEffectView and starts CVDisplayLink polling.
  ///
  /// @param window_id  The palette window identifier
  /// @param enabled    true to enable glass effect, false to disable
  void SetGlassEnabled(ffi.Pointer<ffi.Char> window_id, bool enabled) {
    return _SetGlassEnabled(window_id, enabled);
  }

  late final _SetGlassEnabledPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Bool)>
      >('FloatingPalette_SetGlassEnabled');
  late final _SetGlassEnabled =
      _SetGlassEnabledPtr.asFunction<
        void Function(ffi.Pointer<ffi.Char>, bool)
      >(isLeaf: true);

  /// Set the blur material for the glass effect.
  ///
  /// @param window_id  The palette window identifier
  /// @param material   Material index: 0=hudWindow, 1=sidebar, 2=popover, 3=menu, 4=sheet
  void SetGlassMaterial(ffi.Pointer<ffi.Char> window_id, int material) {
    return _SetGlassMaterial(window_id, material);
  }

  late final _SetGlassMaterialPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int32)>
      >('FloatingPalette_SetGlassMaterial');
  late final _SetGlassMaterial =
      _SetGlassMaterialPtr.asFunction<
        void Function(ffi.Pointer<ffi.Char>, int)
      >(isLeaf: true);
}
