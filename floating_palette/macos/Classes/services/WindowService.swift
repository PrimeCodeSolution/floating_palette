import Cocoa
import FlutterMacOS
import os.log

/// Handles window lifecycle: create, destroy, content.
final class WindowService {
    private let store = WindowStore.shared
    private weak var registrar: FlutterPluginRegistrar?
    private var eventSink: ((String, String, String?, [String: Any]) -> Void)?

    /// Reference to background capture service for self channel commands
    private var backgroundCaptureService: BackgroundCaptureService?

    /// Reference to frame service for window frame observers
    private var frameService: FrameService?

    /// Reference to snap service for snap notifications
    private var snapService: SnapService?

    /// Reference to drag coordinator for drag lifecycle management
    private var dragCoordinator: DragCoordinator?

    /// Reference to input service for cleanup on window destruction
    private var inputService: InputService?

    /// Entry point for palettes - generated by floating_palette_generator
    private let paletteEntryPoint = "paletteMain"

    init(registrar: FlutterPluginRegistrar?) {
        self.registrar = registrar
    }

    /// Set reference to background capture service for self channel handling.
    func setBackgroundCaptureService(_ service: BackgroundCaptureService?) {
        self.backgroundCaptureService = service
    }

    /// Set reference to frame service for window frame observers.
    func setFrameService(_ service: FrameService?) {
        self.frameService = service
    }

    /// Set reference to snap service for snap notifications.
    func setSnapService(_ service: SnapService?) {
        self.snapService = service
    }

    /// Set reference to drag coordinator for drag lifecycle management.
    func setDragCoordinator(_ coordinator: DragCoordinator?) {
        self.dragCoordinator = coordinator
    }

    /// Set reference to input service for cleanup on window destruction.
    func setInputService(_ service: InputService?) {
        self.inputService = service
    }

    func setEventSink(_ sink: @escaping (String, String, String?, [String: Any]) -> Void) {
        self.eventSink = sink
    }

    // MARK: - Commands

    func handle(_ command: String, windowId: String?, params: [String: Any], result: @escaping FlutterResult) {
        switch command {
        case "create":
            create(params: params, result: result)
        case "destroy":
            destroy(windowId: windowId, result: result)
        case "exists":
            exists(windowId: windowId, result: result)
        case "setEntryPoint":
            setEntryPoint(windowId: windowId, params: params, result: result)
        default:
            result(FlutterError(code: "UNKNOWN_COMMAND", message: "Unknown window command: \(command)", details: nil))
        }
    }

    // MARK: - Create

    private func create(params: [String: Any], result: @escaping FlutterResult) {
        guard let id = params["id"] as? String else {
            os_log("create failed: missing id", log: Log.window, type: .error)
            result(FlutterError(code: "MISSING_ID", message: "Window ID required", details: nil))
            return
        }

        if store.exists(id) {
            os_log("create failed: already exists id=%{public}@", log: Log.window, type: .error, id)
            result(FlutterError(code: "ALREADY_EXISTS", message: "Window \(id) already exists", details: nil))
            return
        }

        os_log("create id=%{public}@", log: Log.window, type: .info, id)

        let cornerRadius = params["cornerRadius"] as? CGFloat ?? 12
        let shadowName = params["shadow"] as? String ?? "standard"
        let transparent = params["transparent"] as? Bool ?? true
        let backgroundColor = params["backgroundColor"] as? Int
        let resizable = params["resizable"] as? Bool ?? false
        let allowSnap = params["allowSnap"] as? Bool ?? false
        let debugBorder = params["debugBorder"] as? Bool ?? false
        let keepAlive = params["keepAlive"] as? Bool ?? false

        // Size config - stored for runtime queries from palette
        let width = params["width"] as? CGFloat ?? 400
        let minWidth = params["minWidth"] as? CGFloat ?? 200
        let minHeight = params["minHeight"] as? CGFloat ?? 100
        let maxHeight = params["maxHeight"] as? CGFloat ?? 600

        let sizeConfig: [String: Any] = [
            "width": width,
            "minWidth": minWidth,
            "minHeight": minHeight,
            "maxHeight": maxHeight,
            "resizable": resizable,
        ]

        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }

            // Create Flutter engine (don't run yet - need view setup first)
            let engine = FlutterEngine(name: id, project: nil, allowHeadlessExecution: true)

            // Create panel with initial size
            let panel = self.createPanel(
                cornerRadius: cornerRadius,
                shadow: shadowName,
                transparent: transparent,
                backgroundColor: backgroundColor,
                resizable: resizable,
                allowSnap: allowSnap
            )

            // Wire up focus events (sent to both main app AND palette engine)
            panel.paletteId = id
            panel.minResizeWidth = minWidth
            panel.minResizeHeight = minHeight

            panel.onFocusChanged = { [weak self] windowId, focused in
                // Send to main app channel
                self?.eventSink?("focus", focused ? "focused" : "unfocused", windowId, [:])

                // Also send directly to the palette's engine via selfChannel
                if let window = WindowStore.shared.get(windowId) {
                    let selfChannel = FlutterMethodChannel(
                        name: "floating_palette/self",
                        binaryMessenger: window.engine.binaryMessenger
                    )
                    selfChannel.invokeMethod(focused ? "onFocusGained" : "onFocusLost", arguments: nil)
                }
            }

            // Create Flutter view controller and set initial frame BEFORE engine runs
            let flutterVC = FlutterViewController(engine: engine, nibName: nil, bundle: nil)
            let initialSize = NSRect(x: 0, y: 0, width: 300, height: 200)
            flutterVC.view.frame = initialSize

            // Enable autoresizing so Flutter view resizes with window
            flutterVC.view.autoresizingMask = [.width, .height]

            // Make Flutter view transparent for rounded corners
            if transparent {
                flutterVC.view.wantsLayer = true
                flutterVC.view.layer?.isOpaque = false
                flutterVC.view.layer?.backgroundColor = CGColor.clear

                // Also make all sublayers transparent (Flutter's metal layer)
                flutterVC.view.subviews.forEach { subview in
                    subview.wantsLayer = true
                    subview.layer?.isOpaque = false
                    subview.layer?.backgroundColor = CGColor.clear
                }
            }

            // Assign to panel
            panel.contentViewController = flutterVC

            // Debug: show red border around panel bounds
            if debugBorder, let contentView = panel.contentView {
                contentView.wantsLayer = true
                contentView.layer?.borderWidth = 2
                contentView.layer?.borderColor = NSColor.red.cgColor
            }

            // NOW run the engine - Flutter will see the correct initial view size
            let entryPointSuccess = engine.run(withEntrypoint: self.paletteEntryPoint)
            guard entryPointSuccess else {
                result(FlutterError(code: "ENGINE_FAILED", message: "Failed to start Flutter engine", details: nil))
                return
            }

            // Re-apply transparency to Metal layer AFTER engine starts
            if transparent {
                self.ensureViewTransparency(flutterVC.view)
            }

            // Set up method channels via router
            let channels = WindowChannelRouter.setupChannels(
                id: id,
                engine: engine,
                eventSink: self.eventSink,
                backgroundCaptureService: self.backgroundCaptureService,
                snapService: self.snapService,
                dragCoordinator: self.dragCoordinator
            )

            // Store window
            let window = PaletteWindow(id: id, panel: panel, flutterViewController: flutterVC, engine: engine)
            window.entryChannel = channels.entry
            window.messengerChannel = channels.messenger
            window.sizeConfig = sizeConfig
            window.keepAlive = keepAlive
            self.store.store(id, window: window)

            // Set up frame observers for snap support
            self.frameService?.observeWindowFrame(window)

            // Send created event
            self.eventSink?("window", "created", id, [:])

            os_log("created id=%{public}@", log: Log.window, type: .info, id)
            result(id)
        }
    }

    /// Recursively ensure view and all sublayers are transparent.
    /// Called after engine starts to catch lazily-created Metal layers.
    private func ensureViewTransparency(_ view: NSView) {
        view.wantsLayer = true
        view.layer?.isOpaque = false
        view.layer?.backgroundColor = CGColor.clear

        // Recursively handle all subviews (including Flutter's Metal view)
        for subview in view.subviews {
            ensureViewTransparency(subview)
        }

        // Also handle sublayers directly (Metal layer might not have a view)
        if let sublayers = view.layer?.sublayers {
            for sublayer in sublayers {
                sublayer.isOpaque = false
                sublayer.backgroundColor = CGColor.clear
            }
        }
    }

    private func createPanel(cornerRadius: CGFloat, shadow: String, transparent: Bool, backgroundColor: Int?, resizable: Bool, allowSnap: Bool) -> KeyablePanel {
        // Borderless by default. Add .resizable only when snapping is enabled.
        var styleMask: NSWindow.StyleMask = [.borderless, .nonactivatingPanel]
        if resizable && allowSnap {
            styleMask.insert(.resizable)
        }
        let panel = KeyablePanel(
            contentRect: NSRect(x: 0, y: 0, width: 300, height: 200),
            styleMask: styleMask,
            backing: .buffered,
            defer: false
        )

        // Enable custom resize handling
        panel.allowsUserResize = resizable

        // Panel behavior
        panel.level = .floating
        panel.isFloatingPanel = true
        panel.hidesOnDeactivate = false
        panel.collectionBehavior = [.moveToActiveSpace, .fullScreenAuxiliary]
        panel.isMovableByWindowBackground = false
        panel.isOpaque = false
        panel.hasShadow = shadow != "none"
        panel.acceptsMouseMovedEvents = true

        // Background
        if transparent {
            panel.backgroundColor = .clear
        } else if let colorValue = backgroundColor {
            panel.backgroundColor = NSColor(
                red: CGFloat((colorValue >> 16) & 0xFF) / 255.0,
                green: CGFloat((colorValue >> 8) & 0xFF) / 255.0,
                blue: CGFloat(colorValue & 0xFF) / 255.0,
                alpha: CGFloat((colorValue >> 24) & 0xFF) / 255.0
            )
        }

        return panel
    }

    // MARK: - Destroy

    private func destroy(windowId: String?, result: @escaping FlutterResult) {
        guard let id = windowId else {
            os_log("destroy failed: missing id", log: Log.window, type: .error)
            result(FlutterError(code: "MISSING_ID", message: "Window ID required", details: nil))
            return
        }

        os_log("destroy id=%{public}@", log: Log.window, type: .info, id)

        guard let window = store.get(id) else {
            os_log("destroy failed: not found id=%{public}@", log: Log.window, type: .error, id)
            result(FlutterError(code: "NOT_FOUND", message: "Window \(id) not found", details: nil))
            return
        }

        window.markDestroyed()
        store.remove(id)

        // Clean up glass effect resources
        GlassMaskService.shared.cleanup(windowId: id)

        // Clean up frame observers
        frameService?.removeObservers(for: id)

        // Clean up input captures
        inputService?.cleanupForWindow(id)

        // Notify snap service of window destruction
        snapService?.onWindowDestroyed(id: id)

        DispatchQueue.main.async { [weak self] in
            window.panel.orderOut(nil)
            window.engine.shutDownEngine()

            self?.eventSink?("window", "destroyed", id, [:])
            os_log("destroyed id=%{public}@", log: Log.window, type: .info, id)
            result(nil)
        }
    }

    // MARK: - Exists

    private func exists(windowId: String?, result: @escaping FlutterResult) {
        guard let id = windowId else {
            result(false)
            return
        }
        result(store.exists(id))
    }

    // MARK: - Entry Point

    private func setEntryPoint(windowId: String?, params: [String: Any], result: @escaping FlutterResult) {
        // Entry point can only be set at creation time in Flutter
        result(FlutterError(code: "NOT_SUPPORTED", message: "Entry point can only be set at creation", details: nil))
    }
}
